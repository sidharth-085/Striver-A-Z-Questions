#include <iostream>
#include <unordered_map>
#include <unordered_set>
#include <vector>
using namespace std;

// DFS Method

void dfs(int vertex, int &malwareSize, vector<int> &visited, vector<vector<int>> &graph, unordered_set<int> &infected, vector<int> &infNodes) {
    visited[vertex] = 1;
    malwareSize++;

    if (infected.find(vertex) != infected.end()) {
        infNodes.push_back(vertex);
    }

    for (int &neighbour : graph[vertex]) {
        if (!visited[neighbour]) {
            dfs(neighbour, malwareSize, visited, graph, infected, infNodes);
        }
    }
}

int minMalwareSpread(vector<vector<int>>& grid, vector<int>& initial) {
    int n = grid.size();

    vector<vector<int>> graph(n);

    for (int row = 0; row < n; row++) {
        for (int col = 0; col < n; col++) {
            if (grid[row][col] == 1) {
                graph[row].push_back(col);
            }
        }
    }

    unordered_set<int> infected;

    for (int &infNode : initial) {
        infected.insert(infNode);
    }

    vector<int> visited(n, 0);

    vector<int> uninfected(n, 0);

    for (int vertex = 0; vertex < n; vertex++) {
        if (!visited[vertex]) {
            int malwareSize = 0;
            vector<int> infNodes;

            dfs(vertex, malwareSize, visited, graph, infected, infNodes);

            if (infNodes.size() == 1) {
                int infNode = infNodes[0];
                uninfected[infNode] = malwareSize;
            }  
        }
    }

    int maxSize = 0; 
    int ansNode = 1e9;

    for (int infNode = 0; infNode < n; infNode++) {
        if (uninfected[infNode] > maxSize) {
            maxSize = uninfected[infNode];
            ansNode = infNode;
        }
    }

    if (ansNode == 1e9) {
        return *(min_element(initial.begin(), initial.end()));
    }

    return ansNode;
}

// DSU Method

class DSU {
    public: 

    vector<int> size;
    vector<int> parent;

    DSU(int n) {
        size.resize(n + 1, 1);
        parent.resize(n + 1);
        
        for (int i=0; i<=n; i++) {
            parent[i] = i;
        }
    }

    int findParent(int vertex) {
        int temp = vertex;
        while (temp != parent[temp]) {
            temp = parent[temp];
        }
        return parent[vertex] = temp;
    }

    void unionBySize(int u, int v) {
        int up_u = findParent(u);
        int up_v = findParent(v);

        if (up_u == up_v) {
            return;
        }

        if (size[up_u] > size[up_v]) {
            parent[up_v] = up_u;
            size[up_u] = size[up_u] + size[up_v];
        }
        else {
            parent[up_u] = up_v;
            size[up_v] = size[up_v] + size[up_u];
        }
    }
};

int minMalwareSpread(vector<vector<int>>& grid, vector<int>& initialInfNodes) {
    int n = grid.size();

    DSU dsu(n);

    for (int row = 0; row < n; row++) {
        for (int col = 0; col < n; col++) {
            if (row != col && grid[row][col] == 1) {
                dsu.unionBySize(row, col);
            }
        }
    }

    vector<int> infNodeCount(n, 0);
    vector<pair<int, int>> infNodeCompSize(n);

    for (auto &initInfNode : initialInfNodes) {
        int infNodePar = dsu.findParent(initInfNode);

        infNodeCount[infNodePar]++;
        infNodeCompSize[infNodePar] = {initInfNode, dsu.size[infNodePar]};
    }

    int ansNode = 1e9;
    int size = -1;

    for (int vertex = 0; vertex < n; vertex++) {
        if (infNodeCount[vertex] == 1) {
            if (infNodeCompSize[vertex].second > size) {
                ansNode = infNodeCompSize[vertex].first; 
                size = infNodeCompSize[vertex].second;
            }
            else if (infNodeCompSize[vertex].second == size) {
                ansNode = min(ansNode, infNodeCompSize[vertex].first);
            }
        } 
    }

    if (ansNode == 1e9) {
        return *(min_element(initialInfNodes.begin(), initialInfNodes.end()));
    }

    return ansNode;
}